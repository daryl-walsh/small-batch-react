"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const console_1 = require("console");
const fs = tslib_1.__importStar(require("fs"));
const fuzzy = tslib_1.__importStar(require("fuzzy"));
const globby_1 = tslib_1.__importDefault(require("globby"));
const inquirer = tslib_1.__importStar(require("inquirer"));
const inquirer_autocomplete_prompt_1 = tslib_1.__importDefault(require("inquirer-autocomplete-prompt"));
const symbols = tslib_1.__importStar(require("log-symbols"));
const mkdirp_1 = tslib_1.__importDefault(require("mkdirp"));
const node_emoji_1 = require("node-emoji");
const path = tslib_1.__importStar(require("path"));
const windowSize = tslib_1.__importStar(require("window-size"));
const flags_1 = require("../flags");
const compiler_1 = require("../template/compiler");
const context_1 = require("../template/context");
const reader_1 = require("../template/reader");
const utils_1 = require("../utils");
const LIST_PAGE_SIZE = windowSize.height - 10;
const searchDir = (directories) => (_, input = '') => {
    return new Promise((resolve) => {
        const fuzzyResult = fuzzy.filter(input, directories);
        resolve(fuzzyResult.map((el) => el.original));
    });
};
// inquirer can fuzzy search
inquirer.registerPrompt('autocomplete', inquirer_autocomplete_prompt_1.default);
class GenerateCommand extends command_1.Command {
    async run() {
        const { args, flags: { templateDir, dryRun }, } = this.parse(GenerateCommand);
        console_1.clear();
        let templateName = args.templateName;
        const cwd = process.cwd();
        const dir = path.resolve(cwd, templateDir);
        const reader = new reader_1.Reader(dir);
        const documents = reader.readAll();
        // prepare template name
        if (templateName == null) {
            if (documents.length < 1) {
                return this.error('Please create a template!', { exit: 1 });
            }
            const { choice } = await inquirer.prompt([
                {
                    name: 'choice',
                    message: 'Please select a template',
                    type: 'list',
                    choices: documents.map(({ attributes }) => attributes.name),
                    pageSize: LIST_PAGE_SIZE,
                },
            ]);
            templateName = choice;
        }
        // search target document
        const document = documents.find(({ attributes }) => attributes.name === templateName);
        if (document == null) {
            return this.error(`template "${templateName}" does not exist.`, { exit: 1 });
        }
        // search target directories
        const root = path.resolve(cwd, document.attributes.root);
        let directories = globby_1.default.sync(path.join(root, document.attributes.output), {
            onlyFiles: false,
            onlyDirectories: true,
            ignore: document.attributes.ignore.map((ignore) => path.join(root, ignore)),
        });
        directories = [root, ...directories].map((directory) => path.join(path.relative(cwd, directory)));
        // prepare output & input
        const { dist, input } = await inquirer.prompt([
            {
                name: 'dist',
                message: 'Please select the output destination directory.',
                type: 'autocomplete',
                source: searchDir(directories),
                pageSize: LIST_PAGE_SIZE,
            },
            {
                name: 'input',
                message: document.attributes.message,
                type: 'input',
                validate: (v) => (v !== '' ? true : 'required input!'),
            },
        ]);
        const results = document.resources.map(({ filename, content }) => {
            const fname = compiler_1.Compiler.compile(context_1.createContext(document, new Map([['input', input], ['root', document.attributes.root]])), filename);
            const output = path.join(dist, fname);
            const info = path.parse(output);
            return {
                filename: path.join(dist, fname),
                content: compiler_1.Compiler.compile(context_1.createContext(document, new Map([
                    ['input', input],
                    ['basename', info.base],
                    ['filename', info.name],
                    ['extname', info.ext],
                    ['root', document.attributes.root],
                    ['output', output],
                ])), content),
            };
        });
        return dryRun ? this.dryRun(results) : await this.writeFiles(results);
    }
    dryRun(resources) {
        resources.forEach(({ filename, content }) => {
            this.log('');
            this.log(chalk_1.default.gray('-'.repeat(windowSize.width)));
            this.log(`${symbols.success}  File: ${chalk_1.default.bold(filename)}`);
            this.log(chalk_1.default.gray('-'.repeat(windowSize.width)));
            this.log(content);
            this.log('');
        });
        this.log('');
        return this.exit(0);
    }
    async writeFiles(resources) {
        const writes = [];
        const skips = [];
        try {
            for (const { filename, content } of resources) {
                mkdirp_1.default.sync(path.dirname(filename));
                if (utils_1.fileExists(filename)) {
                    const { ok } = await inquirer.prompt([
                        {
                            name: 'ok',
                            type: 'confirm',
                            message: `Would you like to overwrite it? ("${filename}")`,
                            prefix: `${symbols.warning} `,
                            default: false,
                        },
                    ]);
                    if (!ok) {
                        skips.push(filename);
                        continue;
                    }
                }
                fs.writeFileSync(filename, content, 'utf8');
                writes.push(filename);
            }
        }
        catch (e) {
            this.error(e, { exit: 1 });
        }
        this.log(node_emoji_1.emojify(`
:sparkles: ${chalk_1.default.green('Completed scaffolding !')}
`));
        writes.forEach((filename) => {
            this.log(`    ${symbols.success} ${chalk_1.default.bold(filename)}`);
        });
        skips.forEach((filename) => {
            this.log(`    ${symbols.warning} ${filename} ${chalk_1.default.gray('(skipped)')}`);
        });
        this.log('');
        return this.exit(0);
    }
}
GenerateCommand.description = 'Scaffold using the specified template. If you do not specify the template name and execute it, interactively select the template.';
GenerateCommand.args = [{ name: 'templateName' }];
GenerateCommand.flags = Object.assign({}, flags_1.commonFlags, { dryRun: command_1.flags.boolean({
        char: 'n',
        description: 'Output the result to stdout.',
        default: false,
    }) });
exports.default = GenerateCommand;
//# sourceMappingURL=generate.js.map