"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const esprima = tslib_1.__importStar(require("esprima"));
const tokens_1 = require("./tokens");
// TODO More appropriate error message
const unexpected = () => {
    throw new Error('unexpected token');
};
const unclosed = () => {
    throw new Error('unclosing tag');
};
const unopened = () => {
    throw new Error('unopened tag');
};
const parseNumeric = (value) => Number(value);
const tokenizeInTag = (input) => {
    const output = [];
    const tokens = esprima.tokenize(input);
    const length = tokens.length;
    let pos = 0;
    const endOfSource = (index) => index + 1 > length;
    const lookahead = () => (endOfSource(pos + 1) ? null : tokens[pos + 1]);
    while (!endOfSource(pos)) {
        const token = tokens[pos];
        switch (token.type) {
            case 'Null':
                output.push(tokens_1.createToken(tokens_1.TokenType.NULL, null));
                break;
            case 'String':
                output.push(tokens_1.createToken(tokens_1.TokenType.STRING, token.value.slice(1, token.value.length - 1)));
                break;
            case 'Boolean':
                output.push(tokens_1.createToken(tokens_1.TokenType.BOOLEAN, token.value === 'true'));
                break;
            case 'Numeric':
                output.push(tokens_1.createToken(tokens_1.TokenType.NUMBER, parseNumeric(token.value)));
                break;
            case 'Identifier':
                switch (token.value) {
                    case 'undefined':
                        output.push(tokens_1.createToken(tokens_1.TokenType.UNDEFINED, undefined));
                        break;
                    default:
                        output.push(tokens_1.createToken(tokens_1.TokenType.IDENT, token.value));
                }
                break;
            case 'Punctuator':
                switch (token.value) {
                    case '+':
                    case '-':
                        const next = lookahead();
                        if (next != null && next.type === 'Numeric') {
                            output.push(tokens_1.createToken(tokens_1.TokenType.NUMBER, parseNumeric(`${token.value}${next.value}`)));
                            pos++;
                        }
                        else {
                            unexpected();
                        }
                        break;
                    case '|':
                        output.push(tokens_1.createToken(tokens_1.TokenType.PIPE, '|'));
                        break;
                    default:
                        unexpected();
                }
                break;
            default:
                unexpected();
        }
        pos++;
    }
    return output;
};
exports.tokenize = (input) => {
    const source = Array.from(input);
    const length = source.length;
    let output = [];
    let buffer = [];
    let inTag = false;
    let pos = 0;
    const endOfSource = (index) => index + 1 > length;
    const lookahead = () => (endOfSource(pos + 1) ? '' : source[pos + 1]);
    const buf2str = () => buffer.join('');
    const consumeBuffer = () => {
        if (buffer.length > 0) {
            output.push(tokens_1.createToken(tokens_1.TokenType.STRING, buf2str()));
            buffer = [];
        }
    };
    while (!endOfSource(pos)) {
        const str = source[pos];
        switch (str) {
            case '{':
                if (lookahead() === '{') {
                    if (inTag) {
                        unclosed();
                    }
                    inTag = true;
                    consumeBuffer();
                    output.push(tokens_1.createToken(tokens_1.TokenType.OPEN_TAG, '{{'));
                    pos++;
                }
                else {
                    buffer.push(str);
                }
                break;
            case '}':
                if (lookahead() === '}') {
                    if (!inTag) {
                        unopened();
                    }
                    inTag = false;
                    output = [...output, ...tokenizeInTag(buf2str()), tokens_1.createToken(tokens_1.TokenType.CLOSE_TAG, '}}')];
                    pos++;
                    buffer = [];
                }
                else {
                    buffer.push(str);
                }
                break;
            default:
                buffer.push(str);
        }
        pos++;
    }
    if (inTag) {
        unclosed();
    }
    consumeBuffer();
    return output;
};
//# sourceMappingURL=tokenize.js.map