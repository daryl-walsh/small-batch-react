"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ast_1 = require("./ast");
const tokens_1 = require("./tokens");
const eofToken = tokens_1.createToken(tokens_1.TokenType.EOF, null);
class Parser {
    constructor(tokens) {
        this.pos = 0;
        this.current = eofToken;
        this.next = eofToken;
        this.tokens = tokens;
        this.length = tokens.length;
        this.bump();
    }
    parse() {
        const ast = [];
        while (!this.endOfTokens()) {
            switch (this.current.type) {
                case tokens_1.TokenType.OPEN_TAG:
                    ast.push(this.parseTagExpr());
                    break;
                case tokens_1.TokenType.STRING:
                    ast.push(new ast_1.RawExpr(this.current.literal));
                    break;
            }
            this.bump();
        }
        return ast;
    }
    endOfTokens() {
        return this.current.type === tokens_1.TokenType.EOF;
    }
    bump() {
        if (this.pos < this.length) {
            this.current = this.tokens[this.pos];
            this.pos++;
        }
        else {
            this.current = eofToken;
        }
        if (this.pos < this.length) {
            this.next = this.tokens[this.pos];
        }
        else {
            this.next = eofToken;
        }
    }
    parseTagExpr() {
        const expressions = [];
        let passedPipe = false;
        this.bump();
        while (!this.endOfTokens()) {
            switch (this.current.type) {
                case tokens_1.TokenType.IDENT:
                    switch (this.next.type) {
                        case tokens_1.TokenType.NULL:
                        case tokens_1.TokenType.UNDEFINED:
                        case tokens_1.TokenType.BOOLEAN:
                        case tokens_1.TokenType.STRING:
                        case tokens_1.TokenType.NUMBER:
                        case tokens_1.TokenType.IDENT:
                            expressions.push(this.parseCallExpr());
                            break;
                        // case TokenType.IDENT:
                        //   throw new Error('unexpected syntax (invalid identitifer)');
                        default:
                            if (passedPipe) {
                                expressions.push(new ast_1.CallExpr(this.current.literal, []));
                            }
                            else {
                                expressions.push(new ast_1.IdentExpr(new ast_1.Ident(this.current.literal)));
                            }
                    }
                    break;
                case tokens_1.TokenType.NULL:
                case tokens_1.TokenType.UNDEFINED:
                case tokens_1.TokenType.BOOLEAN:
                case tokens_1.TokenType.STRING:
                case tokens_1.TokenType.NUMBER:
                    expressions.push(new ast_1.LiteralExpr(new ast_1.Literal(this.current.literal)));
                    break;
                case tokens_1.TokenType.PIPE:
                    passedPipe = true;
                    break;
                case tokens_1.TokenType.CLOSE_TAG:
                    return new ast_1.TagExpr(this.combineTagExpressions(expressions));
            }
            this.bump();
        }
        throw new Error('unexpected syntax');
    }
    combineTagExpressions(expressions) {
        const copy = [...expressions];
        const expr = copy.shift();
        if (expr == null) {
            return [];
        }
        const combined = copy.reduce((acc, cur) => {
            if (cur instanceof ast_1.CallExpr) {
                cur.args = [acc, ...(cur.args == null ? [] : cur.args)];
                return cur;
            }
            return acc;
        }, expr);
        return [combined];
    }
    parseCallExpr() {
        const name = this.current.literal;
        const args = [];
        this.bump();
        while (!this.endOfTokens()) {
            if (this.current.type === tokens_1.TokenType.IDENT) {
                args.push(new ast_1.IdentExpr(new ast_1.Ident(this.current.literal)));
            }
            else {
                args.push(new ast_1.LiteralExpr(new ast_1.Literal(this.current.literal)));
            }
            switch (this.next.type) {
                case tokens_1.TokenType.CLOSE_TAG:
                case tokens_1.TokenType.PIPE:
                    return new ast_1.CallExpr(name, args);
                default:
                    this.bump();
            }
        }
        throw new Error('unexpected syntax');
    }
}
exports.Parser = Parser;
//# sourceMappingURL=parser.js.map