"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ast_1 = require("./ast");
const parser_1 = require("./parser");
const tokenize_1 = require("./tokenize");
class Compiler {
    constructor(context) {
        this.context = context;
    }
    static compile(context, input) {
        const parser = new parser_1.Parser(tokenize_1.tokenize(input));
        const compiler = new Compiler(context);
        return compiler.compile(parser.parse());
    }
    compile(ast) {
        let output = '';
        for (const expr of ast) {
            if (expr instanceof ast_1.RawExpr) {
                output += expr.toString();
            }
            else if (expr instanceof ast_1.TagExpr) {
                output += this.compileTagExpr(expr);
            }
        }
        return output;
    }
    compileTagExpr(tagExpr) {
        let output = '';
        for (const expr of tagExpr.expressions) {
            if (expr instanceof ast_1.LiteralExpr) {
                output += this.compileLiteralExpr(expr);
            }
            else if (expr instanceof ast_1.IdentExpr) {
                output += this.compileIdentExpr(expr);
            }
            else if (expr instanceof ast_1.CallExpr) {
                output += this.compileCallExpr(expr);
            }
        }
        return output;
    }
    compileIdentExpr(identExpr) {
        const { vars, funcs } = this.context;
        const value = vars.get(identExpr.ident.name);
        const fn = funcs.get(identExpr.ident.name);
        if (value != null) {
            return value;
        }
        if (fn != null) {
            return fn(this.context);
        }
        throw new Error(`"${identExpr.ident.name}" identifier does not exist.`);
    }
    compileLiteralExpr(literalExpr) {
        switch (typeof literalExpr.literal.value) {
            case 'string':
            case 'number':
                return `${literalExpr.literal.value}`;
                break;
            default:
                return '';
        }
    }
    compileCallExpr(callExpr) {
        const { funcs } = this.context;
        const fn = funcs.get(callExpr.name);
        if (fn == null) {
            throw new Error(`"${callExpr.name}" function does not exist.`);
        }
        const args = callExpr.args.map((expr) => {
            if (expr instanceof ast_1.LiteralExpr) {
                return expr.literal.value;
            }
            else if (expr instanceof ast_1.IdentExpr) {
                return this.compileIdentExpr(expr);
            }
            else if (expr instanceof ast_1.CallExpr) {
                return this.compileCallExpr(expr);
            }
            throw new Error(`"${expr}" is invalid argument`);
        });
        return fn(this.context, ...args);
    }
}
exports.Compiler = Compiler;
//# sourceMappingURL=compiler.js.map